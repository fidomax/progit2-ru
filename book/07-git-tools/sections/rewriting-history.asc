[[_rewriting_history]]
=== Исправление истории

Неоднократно при работе с Git, вам может потребоваться по какой-то причине исправить вашу историю фиксаций.
Одно из преимуществ Git заключается в том, что он позволяет вам отложить принятие решений на самый последний момент.
Область подготовленных изменений позволяет вам решить, какие файлы попадут в фиксацию непосредственно перед ее выполнением; благодаря команде `stash` вы можете решить, что не хотите продолжать работу над какими-то изменениями; также вы можете изменить уже совершенные фиксации так, чтобы они выглядели совершенно другим образом.
В частности, можно изменить порядок фиксаций, сообщения или измененные в фиксациях файлы, объединить вместе или разбить на части фиксации, полностью удалить фиксации – но только до того, как вы поделитесь своими наработками с другими.

В данном разделе вы узнаете, как выполнять эти очень полезные задачи. Таким образом, перед тем, как поделиться вашими наработками с другими, вы сможете привести вашу историю фиксаций к нужному виду.

[[_git_amend]]
==== Изменение последней фиксации

Изменение вашей последней фиксации, наверное, наиболее частое исправление истории, которое вы будете выполнять.
Наиболее часто с вашей последней фиксацией вам будет нужно сделать две основные операции: изменить сообщение фиксации или изменить только что сделанный снимок, добавив, изменив или удалив файлы.

Если вы хотите изменить только сообщение вашей последней фиксации, это очень просто:

[source,console]
----
$ git commit --amend
----

Эта команда откроет в вашем текстовом редакторе сообщение вашей последней фиксации, для того, чтобы вы могли его исправить.
Когда вы сохраните его и закроете редактор, будет создана новая фиксация, содержащая это сообщение, которая теперь и будет вашей последней фиксацией.

Если вы создали фиксацию и затем хотите изменить зафиксированный снимок, добавив или изменив файлы (возможно, вы забыли добавить вновь созданный файл, когда совершали изначальную фиксацию), то процесс выглядит в основном так же.
Вы добавляете в индекс необходимые изменения, редактируя файл и выполняя для него `git add` или `git rm` для отслеживаемого файла, а последующая команда `git commit --amend` берет вашу текущую область подготовленных изменений и делает ее снимок для новой фиксации.

Вы должны быть осторожными, используя этот прием, так как при этом изменяется SHA-1 фиксации.
Поэтому как и с операцией `rebase` – не изменяйте вашу последнюю фиксацию, если вы уже отправили ее в общий репозиторий.

[[_changing_multiple]]
==== Изменение сообщений нескольких фиксаций

Для изменения фиксации, расположенной раньше в вашей истории, вам нужно обратиться к более сложным инструментам.
В Git отсутствуют инструменты для изменения истории, но вы можете использовать команду `rebase`, чтобы перебазировать группу фиксаций туда же на HEAD, где они были изначально, вместо перемещения их в другое место.
С помощью интерактивного режима команды `rebase`, вы можете останавливаться после каждой нужной вам фиксации и изменять сообщения, добавлять файлы или делать что-то другое, что вам нужно.
Вы можете запустить `rebase` в интерактивном режиме, добавив опцию `-i` к `git rebase`.
Вы должны указать, какие фиксации вы хотите изменить, передав команде фиксацию, на которую нужно выполнить перебазирование.

Например, если вы хотите изменить сообщения последних трех фиксаций, или сообщение какой-то одной фиксации этой группы, то передайте как аргумент команде `git rebase -i` родителя последней фиксации, которую вы хотите изменить – `HEAD~2^` или `HEAD~3`.
Может быть, проще будет запомнить `~3`, так как вы хотите изменить последние три фиксации; но не забывайте, что вы, в действительности, указываете четвертую фиксацию с конца – родителя последней фиксации, которую вы хотите изменить:

[source,console]
----
$ git rebase -i HEAD~3
----

Напомним, что это команда перебазирования – каждая фиксация, входящая в диапазон `HEAD~3..HEAD`, будет изменена вне зависимости от того, изменили вы сообщение или нет.
Не включайте в такой диапазон фиксацию, которая уже была отправлена на центральный сервер – сделав это, вы можете запутать других разработчиков, предоставив вторую версию одних и тех же изменений.

Выполнение этой команды отобразит в вашем текстовом редакторе список фиксаций, в нашем случае, например, следующее:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Важно отметить, что фиксации перечислены в порядке, противоположном порядку, который вы обычно видите при использовании команды `log`.
Если вы выполните `log`, то увидите следующее:

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
----

Обратите внимание на обратный порядок.
Команда `rebase` в интерактивном режиме предоставит вам скрипт, который она будет выполнять.
Она начнет с фиксации, которую вы указали в командной строке (`HEAD~3`) и повторит изменения, внесенные каждой из фиксаций, сверху вниз.
Наверху отображается самая старая фиксация, а не самая новая, потому что она будет повторена первой.

Вам необходимо изменить скрипт так, чтобы он остановился на фиксации, которую вы хотите изменить.
Для этого измените слово `pick' на слово `edit' напротив каждой из фиксаций, после которых скрипт должен остановиться.
Например, для изменения сообщения только третьей фиксации, измените файл следующим образом:

[source,console]
----
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Когда вы сохраните сообщение и выйдете из редактора, Git переместит вас к самой ранней фиксации из списка и вернет вас в командную строку со следующим сообщением:

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
----

Эти инструкции говорят вам в точности то, что нужно сделать.
Введите

[source,console]
----
$ git commit --amend
----

Измените сообщение фиксации и выйдите из редактора.
Затем выполните

[source,console]
----
$ git rebase --continue
----

Эта команда автоматически применит две оставшиеся фиксации и завершится.
Если вы измените `pick' на `edit' в других строках, то можете повторить эти шаги для соответствующих фиксаций.
Каждый раз Git будет останавливаться, позволяя вам исправить фиксацию, и продолжит, когда вы закончите.

==== Переупорядочивание фиксаций

Вы также можете использовать интерактивное перебазирование для переупорядочивания или полного удаления фиксаций.
Если вы хотите удалить фиксацию ``added cat-file'' и изменить порядок, в котором были внесены две оставшиеся, то вы можете изменить скрипт перебазирования с такого:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

на такой:


[source,console]
----
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
----

Когда вы сохраните скрипт и выйдете из редактора, Git переместит вашу ветку на родителя этих фиксаций, применит `310154e`, затем `f7f3f6d` и после этого остановится.
Вы, фактически, изменили порядок этих фиксаций и полностью удалили фиксацию ``added cat-file''.

[[_squashing]]
==== Объединение фиксаций

С помощью интерактивного режима команды `rebase` также можно объединить последовательность фиксаций в одну.
Git добавляет полезные инструкции в сообщение скрипта перебазирования:

[source,console]
----
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Если вместо ``pick'' или ``edit'' вы укажете ``squash'', Git применит изменения из текущей и предыдущей фиксаций и предложит вам объединить вместе сообщения фиксаций.
Таким образом, если вы хотите из этих трех фиксаций сделать одну, вы должны изменить скрипт следующим образом:

[source,console]
----
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
----

Когда вы сохраните скрипт и выйдете из редактора, Git применит изменения всех трех фиксаций и затем вернет вас обратно в редактор, чтобы вы могли объединить сообщения фиксаций:

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
----

После сохранения сообщения, вы получите одну фиксацию, содержащую изменения всех трех фиксаций, существовавших ранее.

==== Разбиение фиксации

Разбиение фиксации отменяет ее и позволяет затем по частям индексировать и фиксировать изменения, создавая таким образом столько фиксаций, сколько вам нужно.
Например, предположим, что вы хотите разбить среднюю фиксацию на три.
Вместо одной фиксации ``updated README formatting and added blame'' вы хотите получить две разные: первую – ``updated README formatting'', и вторую – ``added blame''.
Вы можете добиться этого, изменив в скрипте `rebase -i` инструкцию для разбиваемой фиксации на ``edit'':

[source,console]
----
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Затем, когда скрипт вернет вас в командную строку, вам нужно будет отменить индексацию изменений этой фиксации, и создать несколько фиксаций на основе этих изменений.
Когда вы сохраните скрипт и выйдете из редактора, Git переместится на родителя первой фиксации в вашем списке, применит первую фиксацию (`f7f3f6d`), применит вторую (`310154e`), и вернет вас в консоль.
Здесь вы можете отменить фиксацию с помощью команды `git reset HEAD^`, которая, фактически, отменит эту фиксацию и удалит из индекса измененные файлы.
Теперь вы можете добавлять в индекс и фиксировать файлы, пока не создадите требуемые фиксации, а после этого выполнить команду `git rebase --continue`:

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
----

Git применит последнюю фиксацию (`a5f4a0d`) из скрипта, и ваша история примет следующий вид:

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
----

И снова, при этом изменились SHA-1 хеши всех фиксаций в вашем списке, поэтому убедитесь, что ни одна фиксация из этого списка ранее не была отправлена в общий репозиторий.

==== Продвинутый инструмент: filter-branch

Существует еще один способ изменения истории, который вы можете использовать при необходимости изменить большое количество фиксаций каким-то программируемым способом – например, изменить глобально ваш адрес электронной почты или удалить файл из всех фиксаций.
Для этого существует команда `filter-branch`, и она может изменять большие периоды вашей истории, поэтому вы, возможно, не должны ее использовать кроме тех случаев, когда ваш проект еще не стал публичным и другие люди еще не имеют наработок, основанных на фиксациях, которые вы собираетесь изменить.
Однако, эта команда может быть очень полезной.
Далее вы ознакомитесь с несколькими обычными вариантами использованиями этой команды, таким образом, вы сможете получить представление о том, на что она способна.

[[_removing_file_every_commit]]
===== Удаление файла из каждой фиксации

Такое случается довольно часто.
Кто-нибудь случайно зафиксировал огромный бинарный файл, неосмотрительно выполнив `git add .`, и вы хотите отовсюду его удалить.
Возможно, вы случайно зафиксировали файл, содержащий пароль, а теперь хотите сделать ваш проект общедоступным.
В общем, утилиту `filter-branch` вы, вероятно, захотите использовать, чтобы привести к нужному виду всю вашу историю.
Для удаления файла passwords.txt из всей вашей истории вы можете использовать опцию `--tree-filter` команды `filter-branch`:

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

Опция `--tree-filter` выполняет указанную команду после переключения на каждую фиксацию и затем повторно фиксирует результаты.
В данном примере, вы удаляете файл passwords.txt из каждого снимка вне зависимости от того, существует он или нет.
Если вы хотите удалить все случайно зафиксированные резервные копии файлов, созданные текстовым редактором, то вы можете выполнить нечто подобное `git filter-branch --tree-filter 'rm -f *~' HEAD`.

Вы можете посмотреть, как Git изменит деревья и фиксации, а затем уже переместить указатель ветки.
Как правило, хорошим подходом будет выполнение всех этих действий в тестовой ветке и, после проверки полученных результатов, установка на нее указателя основной ветки.
Для выполнения `filter-branch` на всех ваших ветках, вы можете передать команде опцию `--all`.

===== Установка поддиректории корневой директорией проекта

Предположим, вы выполнили импорт из другой системы управления исходным кодом и получили в результате поддиректории, которые не имеют никакого смысла (trunk, tags и так далее).
Если вы хотите сделать поддиректорию `trunk` корневой директорией для каждой фиксации, команда `filter-branch` может помочь вам в этом:

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

Теперь вашей новой корневой директорией проекта будет являться поддериктория `trunk`.
Git также автоматически удалит фиксации, которые не затрагивали этой поддиректории.

===== Глобальное изменение адреса электронной почты

Еще один типичный случай возникает, когда вы забыли выполнить `git config` для настройки своего имени и адреса электронной почты перед началом работы, или, возможно, хотите открыть исходные коды вашего рабочего проекта и изменить везде адрес вашей рабочей электронной почты на персональный.
В любом случае вы можете изменить адрес электронный почты сразу в нескольких фиксациях с помощью команды `filter-branch`.
Вы должны быть осторожны, чтобы изменить только свои адреса электронной почты, для этого используйте опцию `--commit-filter`:

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

Эта команда пройдет по всем фиксациям и установит в них ваш новый адрес.
Так как фиксации содержат значения SHA-1 хешей их родителей, эта команда изменяет SHA-1 хеш каждой фиксации в вашей истории, а не только тех, которые соответствовали адресам электронной почты.
